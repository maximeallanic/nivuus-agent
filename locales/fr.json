{
  "greeting": "Bonjour",
  "farewell": "Au revoir",
  "thankYou": "Merci",
  "welcome": "Bienvenue",
  "confirmExecute": "Confirmer l'ex√©cution ?",
  "yesNo": "(oui/non)",
  "pleaseAnswerYesNo": "Veuillez r√©pondre par 'oui' ou 'non'.",
  "executionCancelled": "Ex√©cution annul√©e.",
  "shuttingDown": "üëã Arr√™t de l'agent...",
  "finalSaveCompleted": "üíæ Sauvegarde finale termin√©e.",
  "finalSaveError": "‚ùå Erreur lors de la sauvegarde finale :",
  "agentFinished": "Agent termin√©.",
  "removedLastToolCallRequest": "Suppression du dernier message de l'assistant demandant des appels d'outils de l'historique.",
  "aiRequestsTool": "ü§ñ L'IA demande l'ex√©cution d'un outil...",
  "unknownFunctionRequested": "Erreur : Fonction inconnue demand√©e par l'IA : {functionName}",
  "errorFunctionNotImplemented": "Erreur : La fonction '{functionName}' n'est pas impl√©ment√©e localement.",
  "aiResponseNoContent": "R√©ponse de l'IA sans contenu texte ni appel d'outil.",
  "errorApiKeyNotConfigured": "ERREUR : Cl√© API OpenAI non configur√©e !",
  "errorApiKeyInstructions": "Modifiez la variable OPENAI_API_KEY dans le fichier src/config.js.",
  "warningAxiosMissing": "Attention : Le module 'axios' est requis pour la recherche web (npm install axios).",
  "agentStarted": "--- Agent {modelName} d√©marr√© ---",
  "mainScript": "Script principal : {scriptFilename}",
  "promptInstruction": "Entrez votre instruction ou 'quit' pour quitter.",
  "promptUser": "\nVous (Entr√©e pour '{defaultInstruction}', ou 'quit') : ",
  "defaultInstruction": "Au travail.",
  "discoverSystem": "D√©couvrir le syst√®me sur lequel vous fonctionnez.",
  "proactiveDiscoverSystem": "D√©couvre proactivement le syst√®me sur lequel tu fonctionnes en proposant et ex√©cutant des commandes pertinentes. Apr√®s avoir obtenu les infos sur l'OS, explore le mat√©riel, la m√©moire, l'utilisation disque, la configuration r√©seau, les paquets et services install√©s, etc.",
  "sigintDetected": "\nüëã CTRL+C d√©tect√©. Sauvegarde de l'√©tat avant de quitter...",
  "saveCompleted": "üíæ Sauvegarde termin√©e.",
  "saveError": "‚ùå Erreur lors de la sauvegarde :",
  "exiting": "Fermeture en cours.",
  "memorySummaryTitle": "--- R√©sum√© de la M√©moire Interne ---",
  "memorySysInfo": "Infos Sys :",
  "memoryNotes": "Notes :",
  "memoryActionLog": "Journal d'Actions ({count}/{total}) :",
  "memoryActionLogEntry": "- {time}: [{statusColor}{actionType}/{status}{resetColor}] `{detail}`{errorInfo}",
  "memoryEndOfSummary": "--- Fin du R√©sum√© ---",
  "memoryReminder": "Rappel de l'√©tat actuel et des actions r√©centes :",
  "callingApi": "Appel de l'API OpenAI...",
  "apiResponseReceived": "R√©ponse de l'API re√ßue.",
  "apiError": "Erreur API OpenAI.",
  "toolExecuting": "Ex√©cution de l'outil : {functionName}",
  "toolExecuted": "Outil {toolName} ex√©cut√©.",
  "toolExecutionError": "Erreur lors de l'ex√©cution de l'outil {toolName}.",
  "toolResponseTruncated": "‚Ü™ R√©ponse de l'outil tronqu√©e ({length} > {maxLength})",
  "exitRequestedAfterAction": "Sortie demand√©e apr√®s action (mise √† jour script ?).",
  "errorArgsParsing": "Erreur d'analyse des arguments JSON pour {functionName} : {error}",
  "errorArgsInvalidJson": "Erreur : Arguments invalides fournis par l'IA (pas JSON). Erreur : {message}",
  "errorToolExecution": "Erreur lors de l'ex√©cution locale de l'outil : {message}",
  "errorMainLoop": "\nERREUR INATTENDUE BOUCLE PRINCIPALE :",
  "errorApiGeneric": "\nErreur API OpenAI ({status}) : {message}",
  "errorApi401": "ERREUR 401 : V√©rifiez votre cl√© API OpenAI (OPENAI_API_KEY). Arr√™t.",
  "errorApi429": "ERREUR 429 : Limite de taux API atteinte. Attente sugg√©r√©e avant de r√©essayer.",
  "errorInternalJsonParse": "\nErreur Interne (Analyse Arguments JSON ?) : {message}",
  "errorOccurredRetrying": "\nUne erreur est survenue. Tentative de relance automatique...",
  "errorRetryNoInstruction": "Impossible de trouver la derni√®re instruction utilisateur pour relancer. Utilisation de l'instruction par d√©faut.",
  "errorRetryHistoryCleaned": "Historique restaur√© et nettoy√© avant la derni√®re instruction pour relance.",
  "errorRetryCleanupAssistant": "Nettoyage : Suppression du dernier message assistant avec appels d'outils non r√©solus avant relance.",
  "errorRetryResetHistory": "Nettoyage : R√©initialisation de l'historique (sauf syst√®me) car aucun message utilisateur trouv√© pour relance.",
  "aiAgentName": "ü§ñ {modelName} :",
  "errorNoApiResponse": "Erreur : Aucune r√©ponse de l'API re√ßue.",
  "errorNoResponse": "Erreur : Aucun contenu de r√©ponse trouv√©.",
  "toolCallInitiated": "Appel d'outil initi√©...",
  "toolSuccess": "Outil '{functionName}' ex√©cut√© avec succ√®s.",
  "errorToolNotFound": "Erreur : Outil '{functionName}' non trouv√©.",
  "sendingToolResults": "Envoi des r√©sultats de l'outil √† l'API...",
  "receivedFinalResponse": "R√©ponse finale re√ßue de l'API.",
  "assistantResponseHeader": "--- R√©ponse Assistant ---",
  "errorNoFinalResponse": "Erreur : Aucun contenu de r√©ponse final re√ßu.",
  "errorApiCallFailed": "L'appel API a √©chou√©.",
  "errorUnknown": "Une erreur inconnue est survenue.",
  "commandConfirmPrompt": "\n--- Confirmation Commande ---",
  "commandConfirmProposed": "Commande propos√©e : $ {command}",
  "commandConfirmPurpose": "Objectif commande : {purpose}",
  "notSpecified": "Non sp√©cifi√©",
  "commandStartExecution": "--- D√©but Ex√©cution : $ {command} ---",
  "commandSpawnError": "\nErreur lancement processus : {message}",
  "commandTimeoutError": "\nERREUR : Timeout ({timeout}s) d√©pass√© ! Processus tu√©.",
  "commandTimeoutErrorMsg": "ERREUR SCRIPT : Timeout ({timeout}s) d√©pass√©.",
  "commandEndExecution": "\n--- Fin Ex√©cution (Code : {code}{signalInfo}) ---",
  "commandRawOutputTitle": "--- Sortie Brute Captur√©e ---",
  "commandRawOutputEnd": "--- Fin Sortie Brute --- ",
  "commandOutputStdout": "STDOUT :",
  "commandOutputStderr": "STDERR :",
  "commandOutputNoOutputCode": "(aucune sortie captur√©e, code : {code}{signalInfo})",
  "commandOutputNoOutputSuccess": "(aucune sortie captur√©e, succ√®s)",
  "readFileAttempt": "Tentative de lecture directe : {path}",
  "readFileNotFile": "Le chemin n'est pas un fichier.",
  "readFileTooLarge": "Fichier trop volumineux ({size} > {maxSize} octets). Utilisez des commandes shell (head, tail, grep) √† la place.",
  "readFileBinary": "Le fichier semble √™tre binaire. Lecture directe impossible.",
  "readFileEncodingError": "Impossible de d√©coder avec les encodages courants (utf-8, latin1).",
  "readFileReadSuccess": "Fichier lu : {path}",
  "readFileReadSuccessEncoding": "Lu avec l'encodage {encoding}.",
  "readFileError": "Erreur lecture fichier {path} : {message}",
  "readFileContentHeader": "Contenu de '{path}' :\n```\n{content}\n```",
  "webSearchAttempt": "Recherche web pour : '{query}'...",
  "webSearchNoResults": "Aucun r√©sultat web trouv√© pour '{query}'.",
  "webSearchResultsTitle": "R√©sultats web pour '{query}' :",
  "webSearchResultEntry": "{index}. {title}\n   {body}...\n   {href}",
  "webSearchError": "Erreur recherche web pour '{query}' : {message}",
  "webSearchHttpError": "Erreur HTTP {status} : {statusText}",
  "webSearchTimeoutError": "Timeout de la requ√™te web d√©pass√©.",
  "listDirectoryAttempt": "Tentative de lister le r√©pertoire : {path}",
  "listDirectoryNotDir": "Le chemin sp√©cifi√© n'est pas un r√©pertoire.",
  "listDirectoryEmpty": "(Le r√©pertoire est vide)",
  "listDirectorySuccess": "R√©pertoire list√© : {path}",
  "listDirectoryError": "Erreur listage r√©pertoire {path} : {message}",
  "listDirectoryContentHeader": "Contenu de '{path}' :",
  "listDirectoryEntry": "- {name}{isDir}",
  "fileWriteConfirmPrompt": "\n--- Confirmation √âcriture Fichier ---",
  "fileWriteConfirmProposed": "√âcriture de fichier propos√©e : {filepath}",
  "fileWriteConfirmContent": "Extrait du contenu :\n{contentSnippet}",
  "confirmWrite": "Confirmer l'op√©ration d'√©criture ?",
  "fileWriteCancelled": "√âcriture de fichier annul√©e.",
  "fileWriteAttempt": "Tentative d'√©criture du fichier : {filepath}",
  "fileWriteSuccess": "Fichier √©crit avec succ√®s : {filepath}",
  "fileWriteError": "Erreur lors de l'√©criture du fichier {filepath} : {message}",
  "toolDescriptionGetMemoryKeys": "Liste les cl√©s disponibles sous un chemin sp√©cifique dans la m√©moire interne de l'agent. Si aucun chemin n'est fourni, liste les cl√©s √† la racine.",
  "toolDescriptionGetMemoryValue": "R√©cup√®re la valeur stock√©e √† un chemin sp√©cifique dans la m√©moire interne de l'agent.",
  "toolDescriptionSetMemoryValue": "D√©finit ou met √† jour une valeur √† un chemin sp√©cifique dans la m√©moire interne de l'agent. Cr√©e les chemins imbriqu√©s s'ils n'existent pas.",
  "toolParamMemoryPathOptional": "Le chemin s√©par√© par des points √† inspecter (ex: 'system_info.cpu') (optionnel, racine par d√©faut).",
  "toolParamMemoryPathRequired": "Le chemin s√©par√© par des points pour la valeur (ex: 'system_info.cpu_model', 'notes').",
  "toolParamMemoryValue": "La valeur √† stocker (peut √™tre cha√Æne, nombre, bool√©en, objet ou tableau).",
  "memoryGettingKeys": "M√©moire : R√©cup√©ration des cl√©s pour le chemin : {path}",
  "errorMemoryNotInitialized": "Erreur : La r√©f√©rence m√©moire de l'agent n'est pas initialis√©e.",
  "memoryPathNotFound": "M√©moire : Chemin non trouv√© : {path}",
  "errorMemoryPathNotObject": "Erreur : Le chemin ne pointe pas vers un objet, impossible de lister les cl√©s : {path}",
  "memoryGetKeysSuccess": "M√©moire : Cl√©s r√©cup√©r√©es avec succ√®s pour le chemin : {path}",
  "memoryGetKeysError": "M√©moire : Erreur lors de la r√©cup√©ration des cl√©s pour {path} : {message}",
  "memoryGetKeysErrorFeedback": "Erreur r√©cup√©ration cl√©s m√©moire pour {path} : {message}",
  "memoryGettingValue": "M√©moire : R√©cup√©ration de la valeur pour le chemin : {path}",
  "errorMemoryPathRequired": "Erreur : Le param√®tre de chemin m√©moire est requis.",
  "memoryGetValueSuccess": "M√©moire : Valeur r√©cup√©r√©e avec succ√®s pour le chemin : {path}",
  "memoryGetValueError": "M√©moire : Erreur lors de la r√©cup√©ration de la valeur pour {path} : {message}",
  "memoryGetValueErrorFeedback": "Erreur r√©cup√©ration valeur m√©moire pour {path} : {message}",
  "memorySettingValue": "M√©moire : D√©finition de la valeur pour le chemin : {path}",
  "memorySetValueSuccess": "M√©moire : Valeur d√©finie avec succ√®s pour le chemin : {path}",
  "memorySetValueSuccessFeedback": "Valeur m√©moire d√©finie avec succ√®s pour le chemin : {path}",
  "memorySetValueError": "M√©moire : Erreur lors de la d√©finition de la valeur pour {path} : {message}",
  "memorySetValueErrorFeedback": "Erreur d√©finition valeur m√©moire pour {path} : {message}",
  "fileNotFound": "Fichier non trouv√© : {filePath}. Utilisation des donn√©es par d√©faut.",
  "errorLoadingData": "Erreur chargement donn√©es depuis {filePath} :",
  "errorSavingData": "Erreur sauvegarde donn√©es vers {filePath} :",
  "invalidMemoryUpdate": "Objet m√©moire invalide pass√© √† updateMemory",
  "autoContinuePrompt": "Continuer.",
  "userRequestedQuit": "L'utilisateur a demand√© √† quitter via ask_user.",
  "errorToolExecutionFailed": "L'ex√©cution de l'outil a √©chou√© : {message}",
  "askUserCalledLoopRestart": "ask_user a √©t√© appel√©, red√©marrage de la boucle avec la r√©ponse utilisateur.",
  "assistantQuestionPrefix": "Question Assistant :",
  "promptUserResponse": "Votre r√©ponse : ",
  "errorToolArgsParse": "Erreur d'analyse des arguments pour l'outil {functionName}. Args: {args}. Erreur: {message}",
  "commandConfirmYes": "oui",
  "commandConfirmNo": "non"
}
// filepath: /Projects/nivuus-agent/src/locales.js
export const strings = {
  en: {
    // General
    confirmExecute: "Confirm execution?",
    yesNo: "(yes/no)",
    pleaseAnswerYesNo: "Please answer 'yes' or 'no'.",
    executionCancelled: "Execution cancelled.",
    shuttingDown: "👋 Shutting down agent...",
    finalSaveCompleted: "💾 Final save completed.",
    finalSaveError: "❌ Error during final save:",
    agentFinished: "Agent finished.",
    errorGettingInput: "Error getting user input:",
    invalidInputDefault: "Invalid or no user input received. Using default instruction.",
    usingDefaultInstruction: "Agent: Using default instruction: '{instruction}'",
    aiRequestsTool: "🤖 AI requests tool execution...",
    unknownFunctionRequested: "Error: Unknown function requested by AI: {functionName}",
    errorFunctionNotImplemented: "Error: Function '{functionName}' not implemented locally.",
    aiResponseNoContent: "AI response without text content or tool call.",
    errorApiKeyNotConfigured: "ERROR: OpenAI API Key not configured!",
    errorApiKeyInstructions: "Edit the OPENAI_API_KEY variable in the src/config.js file.",
    warningAxiosMissing: "Warning: 'axios' module required for web search (npm install axios).",
    agentStarted: "--- Agent {modelName} Started ---",
    mainScript: "Main script: {scriptFilename}",
    promptInstruction: "Enter your instruction or 'quit' to exit.",
    promptUser: "\nYou (Enter for '{defaultInstruction}', or 'quit'): ",
    defaultInstruction: "Let's get to work.",
    discoverSystem: "Discover the system you are running on.",
    proactiveDiscoverSystem: "Proactively discover the system you are running on by proposing and executing relevant commands.",
    sigintDetected: "\n👋 CTRL+C detected. Saving state before exiting...",
    saveCompleted: "💾 Save completed.",
    saveError: "❌ Error during save:",
    exiting: "Exiting now.",
    memorySummaryTitle: "--- Internal Memory Summary ---",
    memorySysInfo: "Sys Info:",
    memoryNotes: "Notes:",
    memoryActionLog: "Action Log ({count}/{total}):",
    memoryActionLogEntry: "- {time}: [{statusColor}{actionType}/{status}{resetColor}] `{detail}`{errorInfo}", // Requires color handling or stripping
    memoryEndOfSummary: "--- End Summary ---",
    memoryReminder: "Reminder of current state and recent actions:",
    callingApi: "Calling OpenAI API...",
    apiResponseReceived: "API response received.",
    apiError: "OpenAI API Error.",
    toolExecuting: "Executing tool: {functionName}", // Changed {toolName} to {functionName}
    toolExecuted: "Tool {toolName} executed.",
    toolExecutionError: "Error executing tool {toolName}.",
    toolResponseTruncated: "↪ Tool response truncated ({length} > {maxLength})",
    exitRequestedAfterAction: "Exit requested after action (script update?).",
    errorArgsParsing: "Error parsing JSON arguments for {functionName}: {error}",
    errorArgsInvalidJson: "Error: Invalid arguments provided by AI (not JSON). Error: {message}",
    errorToolExecution: "Error during local tool execution: {message}",
    errorMainLoop: "\nUNEXPECTED MAIN LOOP ERROR:",
    errorApiGeneric: "\nOpenAI API Error ({status}): {message}",
    errorApi401: "ERROR 401: Check your OpenAI API key (OPENAI_API_KEY). Exiting.",
    errorApi429: "ERROR 429: API rate limit reached. Suggested wait before retrying.",
    errorInternalJsonParse: "\nInternal Error (JSON Parse Arguments?): {message}",
    errorOccurredRetrying: "\nAn error occurred. Attempting automatic retry...",
    errorRetryNoInstruction: "Could not find last user instruction for retry. Using default instruction.",
    errorRetryHistoryCleaned: "History restored and cleaned before last instruction for retry.",
    errorRetryCleanupAssistant: "Cleanup: Removing last assistant message with unresolved tool_calls before retry.",
    errorRetryResetHistory: "Cleanup: Resetting history (except system) as no user message found for retry.",
    aiAgentName: "🤖 {modelName}:",
    errorNoApiResponse: "Error: No API response received.",
    errorNoResponse: "Error: No response content found.",
    toolCallInitiated: "Tool call initiated...",
    toolSuccess: "Tool '{functionName}' executed successfully.",
    errorToolNotFound: "Error: Tool '{functionName}' not found.",
    sendingToolResults: "Sending tool results back to API...",
    receivedFinalResponse: "Received final response from API.",
    assistantResponseHeader: "--- Assistant Response ---",
    errorNoFinalResponse: "Error: No final response content received.",
    errorApiCallFailed: "API call failed.",
    errorUnknown: "An unknown error occurred.",
    // tools.js specific
    commandConfirmPrompt: "\n--- Command Confirmation ---",
    commandConfirmProposed: "Proposed command: $ {command}",
    commandConfirmPurpose: "Command purpose: {purpose}",
    notSpecified: "Not specified",
    commandStartExecution: "--- Start Execution: $ {command} ---",
    commandSpawnError: "\nError spawning process: {message}",
    commandTimeoutError: "\nERROR: Timeout ({timeout}s) exceeded! Process killed.",
    commandTimeoutErrorMsg: "SCRIPT ERROR: Timeout ({timeout}s) exceeded.",
    commandEndExecution: "\n--- End Execution (Code: {code}{signalInfo}) ---",
    commandRawOutputTitle: "--- Raw Output Captured ---",
    commandRawOutputEnd: "--- End Raw Output --- ",
    commandOutputStdout: "STDOUT:",
    commandOutputStderr: "STDERR:",
    commandOutputNoOutputCode: "(no output captured, code: {code}{signalInfo})",
    commandOutputNoOutputSuccess: "(no output captured, success)",
    readFileAttempt: "Attempting direct read: {path}",
    readFileNotFile: "Path is not a file.",
    readFileTooLarge: "File too large ({size} > {maxSize} bytes). Use shell commands (head, tail, grep) instead.",
    readFileBinary: "File appears to be binary. Cannot read content directly.",
    readFileEncodingError: "Could not decode with common encodings (utf-8, latin1).",
    readFileReadSuccess: "File read: {path}",
    readFileReadSuccessEncoding: "Read with {encoding} encoding.",
    readFileError: "Error reading file {path}: {message}",
    readFileContentHeader: "Content of '{path}':\n```\n{content}\n```",
    webSearchAttempt: "Performing web search for: '{query}'...",
    webSearchNoResults: "No web results found for '{query}'.",
    webSearchResultsTitle: "Web results for '{query}':",
    webSearchResultEntry: "{index}. {title}\n   {body}...\n   {href}",
    webSearchError: "Web search error for '{query}': {message}",
    webSearchHttpError: "HTTP Error {status}: {statusText}",
    webSearchTimeoutError: "Web request timeout exceeded.",
    listDirectoryAttempt: "Attempting to list directory: {path}",
    listDirectoryNotDir: "Specified path is not a directory.",
    listDirectoryEmpty: "(Directory is empty)",
    listDirectorySuccess: "Directory listed: {path}",
    listDirectoryError: "Error listing directory {path}: {message}",
    listDirectoryContentHeader: "Contents of '{path}':",
    listDirectoryEntry: "- {name}{isDir}",
    fileWriteConfirmPrompt: "\n--- File Write Confirmation ---",
    fileWriteConfirmProposed: "Proposed file write: {filepath}",
    fileWriteConfirmContent: "Content snippet:\n{contentSnippet}",
    confirmWrite: "Confirm write operation?",
    fileWriteCancelled: "File write cancelled.",
    fileWriteAttempt: "Attempting to write file: {filepath}",
    fileWriteSuccess: "Successfully wrote file: {filepath}",
    fileWriteError: "Error writing file {filepath}: {message}",

    // Memory Tools
    toolDescriptionGetMemoryKeys: "Lists the keys available under a specific path in the agent's internal memory. If no path is provided, lists keys at the root.",
    toolDescriptionGetMemoryValue: "Retrieves the value stored at a specific path in the agent's internal memory.",
    toolDescriptionSetMemoryValue: "Sets or updates a value at a specific path in the agent's internal memory. Creates nested paths if they don't exist.",
    toolParamMemoryPathOptional: "The dot-separated path to inspect (e.g., 'system_info.cpu') (optional, defaults to root).",
    toolParamMemoryPathRequired: "The dot-separated path for the value (e.g., 'system_info.cpu_model', 'notes').",
    toolParamMemoryValue: "The value to store (can be string, number, boolean, object, or array).",
    memoryGettingKeys: "Memory: Getting keys for path: {path}",
    errorMemoryNotInitialized: "Error: Agent memory reference is not initialized.",
    memoryPathNotFound: "Memory: Path not found: {path}",
    errorMemoryPathNotObject: "Error: Path does not point to an object, cannot list keys: {path}",
    memoryGetKeysSuccess: "Memory: Successfully retrieved keys for path: {path}",
    memoryGetKeysError: "Memory: Error getting keys for path {path}: {message}",
    memoryGetKeysErrorFeedback: "Error getting memory keys for {path}: {message}",
    memoryGettingValue: "Memory: Getting value for path: {path}",
    errorMemoryPathRequired: "Error: Memory path parameter is required.",
    memoryGetValueSuccess: "Memory: Successfully retrieved value for path: {path}",
    memoryGetValueError: "Memory: Error getting value for path {path}: {message}",
    memoryGetValueErrorFeedback: "Error getting memory value for {path}: {message}",
    memorySettingValue: "Memory: Setting value for path: {path}",
    memorySetValueSuccess: "Memory: Successfully set value for path: {path}",
    memorySetValueSuccessFeedback: "Successfully set memory value for path: {path}",
    memorySetValueError: "Memory: Error setting value for path {path}: {message}",
    memorySetValueErrorFeedback: "Error setting memory value for {path}: {message}",

    // utils.js specific
    fileNotFound: "File not found: {filePath}. Using default data.",
    errorLoadingData: "Error loading data from {filePath}:",
    errorSavingData: "Error saving data to {filePath}:",
    invalidMemoryUpdate: "Invalid memory object passed to updateMemory",

    // New strings for ask_user and auto-continue
    autoContinuePrompt: "Continue.",
    userRequestedQuit: "User requested quit via ask_user.",
    errorToolExecutionFailed: "Tool execution failed: {message}",
    askUserCalledLoopRestart: "ask_user was called, restarting loop with user response.",
    assistantQuestionPrefix: "Assistant Question:",
    promptUserResponse: "Your response: ",

    // Add missing key
    errorToolArgsParse: "Error parsing arguments for tool {functionName}. Args: {args}. Error: {message}",

    // Add missing confirmation keys
    commandConfirmYes: "yes",
    commandConfirmNo: "no",
  },
  fr: {
    // General
    confirmExecute: "Confirmer l'exécution ?",
    yesNo: "(oui/non)",
    pleaseAnswerYesNo: "Veuillez répondre par 'oui' ou 'non'.",
    executionCancelled: "Exécution annulée.",
    shuttingDown: "👋 Arrêt de l'agent...",
    finalSaveCompleted: "💾 Sauvegarde finale terminée.",
    finalSaveError: "❌ Erreur lors de la sauvegarde finale :",
    agentFinished: "Agent terminé.",
    errorGettingInput: "Erreur lors de la récupération de l'entrée utilisateur :",
    invalidInputDefault: "Entrée utilisateur invalide ou absente. Utilisation de l'instruction par défaut.",
    usingDefaultInstruction: "Agent : Utilisation de l'instruction par défaut : '{instruction}'",
    aiRequestsTool: "🤖 L'IA demande l'exécution d'un outil...",
    unknownFunctionRequested: "Erreur : Fonction inconnue demandée par l'IA : {functionName}",
    errorFunctionNotImplemented: "Erreur : La fonction '{functionName}' n'est pas implémentée localement.",
    aiResponseNoContent: "Réponse de l'IA sans contenu texte ni appel d'outil.",
    errorApiKeyNotConfigured: "ERREUR : Clé API OpenAI non configurée !",
    errorApiKeyInstructions: "Modifiez la variable OPENAI_API_KEY dans le fichier src/config.js.",
    warningAxiosMissing: "Attention : Le module 'axios' est requis pour la recherche web (npm install axios).",
    agentStarted: "--- Agent {modelName} démarré ---",
    mainScript: "Script principal : {scriptFilename}",
    promptInstruction: "Entrez votre instruction ou 'quit' pour quitter.",
    promptUser: "\nVous (Entrée pour '{defaultInstruction}', ou 'quit') : ",
    defaultInstruction: "Au travail.",
    discoverSystem: "Découvrir le système sur lequel vous fonctionnez.",
    proactiveDiscoverSystem: "Découvre proactivement le système sur lequel tu fonctionnes en proposant et exécutant des commandes pertinentes (comme 'uname -a', 'lsb_release -a', '/etc/os-release'). Demande confirmation avant d'exécuter. Après avoir obtenu les infos de base sur l'OS, propose d'autres commandes pour explorer le matériel (ex: 'lscpu', 'lspci', 'lsusb'), la mémoire ('free -h'), l'utilisation disque ('df -h'), et la configuration réseau ('ip addr', 'ip route'), en demandant à nouveau confirmation pour chaque groupe.",
    sigintDetected: "\n👋 CTRL+C détecté. Sauvegarde de l'état avant de quitter...",
    saveCompleted: "💾 Sauvegarde terminée.",
    saveError: "❌ Erreur lors de la sauvegarde :",
    exiting: "Fermeture en cours.",
    memorySummaryTitle: "--- Résumé de la Mémoire Interne ---",
    memorySysInfo: "Infos Sys :",
    memoryNotes: "Notes :",
    memoryActionLog: "Journal d'Actions ({count}/{total}) :",
    memoryActionLogEntry: "- {time}: [{statusColor}{actionType}/{status}{resetColor}] `{detail}`{errorInfo}", // Nécessite gestion couleur ou suppression
    memoryEndOfSummary: "--- Fin du Résumé ---",
    memoryReminder: "Rappel de l'état actuel et des actions récentes :",
    callingApi: "Appel de l'API OpenAI...",
    apiResponseReceived: "Réponse de l'API reçue.",
    apiError: "Erreur API OpenAI.",
    toolExecuting: "Exécution de l'outil : {functionName}", // Changed {toolName} to {functionName}
    toolExecuted: "Outil {toolName} exécuté.",
    toolExecutionError: "Erreur lors de l'exécution de l'outil {toolName}.",
    toolResponseTruncated: "↪ Réponse de l'outil tronquée ({length} > {maxLength})",
    exitRequestedAfterAction: "Sortie demandée après action (mise à jour script ?).",
    errorArgsParsing: "Erreur d'analyse des arguments JSON pour {functionName} : {error}",
    errorArgsInvalidJson: "Erreur : Arguments invalides fournis par l'IA (pas JSON). Erreur : {message}",
    errorToolExecution: "Erreur lors de l'exécution locale de l'outil : {message}",
    errorMainLoop: "\nERREUR INATTENDUE BOUCLE PRINCIPALE :",
    errorApiGeneric: "\nErreur API OpenAI ({status}) : {message}",
    errorApi401: "ERREUR 401 : Vérifiez votre clé API OpenAI (OPENAI_API_KEY). Arrêt.",
    errorApi429: "ERREUR 429 : Limite de taux API atteinte. Attente suggérée avant de réessayer.",
    errorInternalJsonParse: "\nErreur Interne (Analyse Arguments JSON ?) : {message}",
    errorOccurredRetrying: "\nUne erreur est survenue. Tentative de relance automatique...",
    errorRetryNoInstruction: "Impossible de trouver la dernière instruction utilisateur pour relancer. Utilisation de l'instruction par défaut.",
    errorRetryHistoryCleaned: "Historique restauré et nettoyé avant la dernière instruction pour relance.",
    errorRetryCleanupAssistant: "Nettoyage : Suppression du dernier message assistant avec appels d'outils non résolus avant relance.",
    errorRetryResetHistory: "Nettoyage : Réinitialisation de l'historique (sauf système) car aucun message utilisateur trouvé pour relance.",
    aiAgentName: "🤖 {modelName} :",
    errorNoApiResponse: "Erreur : Aucune réponse de l'API reçue.",
    errorNoResponse: "Erreur : Aucun contenu de réponse trouvé.",
    toolCallInitiated: "Appel d'outil initié...",
    toolSuccess: "Outil '{functionName}' exécuté avec succès.",
    errorToolNotFound: "Erreur : Outil '{functionName}' non trouvé.",
    sendingToolResults: "Envoi des résultats de l'outil à l'API...",
    receivedFinalResponse: "Réponse finale reçue de l'API.",
    assistantResponseHeader: "--- Réponse Assistant ---",
    errorNoFinalResponse: "Erreur : Aucun contenu de réponse final reçu.",
    errorApiCallFailed: "L'appel API a échoué.",
    errorUnknown: "Une erreur inconnue est survenue.",
    // tools.js specific
    commandConfirmPrompt: "\n--- Confirmation Commande ---",
    commandConfirmProposed: "Commande proposée : $ {command}",
    commandConfirmPurpose: "Objectif commande : {purpose}",
    notSpecified: "Non spécifié",
    commandStartExecution: "--- Début Exécution : $ {command} ---",
    commandSpawnError: "\nErreur lancement processus : {message}",
    commandTimeoutError: "\nERREUR : Timeout ({timeout}s) dépassé ! Processus tué.",
    commandTimeoutErrorMsg: "ERREUR SCRIPT : Timeout ({timeout}s) dépassé.",
    commandEndExecution: "\n--- Fin Exécution (Code : {code}{signalInfo}) ---",
    commandRawOutputTitle: "--- Sortie Brute Capturée ---",
    commandRawOutputEnd: "--- Fin Sortie Brute --- ",
    commandOutputStdout: "STDOUT :",
    commandOutputStderr: "STDERR :",
    commandOutputNoOutputCode: "(aucune sortie capturée, code : {code}{signalInfo})",
    commandOutputNoOutputSuccess: "(aucune sortie capturée, succès)",
    readFileAttempt: "Tentative de lecture directe : {path}",
    readFileNotFile: "Le chemin n'est pas un fichier.",
    readFileTooLarge: "Fichier trop volumineux ({size} > {maxSize} octets). Utilisez des commandes shell (head, tail, grep) à la place.",
    readFileBinary: "Le fichier semble être binaire. Lecture directe impossible.",
    readFileEncodingError: "Impossible de décoder avec les encodages courants (utf-8, latin1).",
    readFileReadSuccess: "Fichier lu : {path}",
    readFileReadSuccessEncoding: "Lu avec l'encodage {encoding}.",
    readFileError: "Erreur lecture fichier {path} : {message}",
    readFileContentHeader: "Contenu de '{path}' :\n```\n{content}\n```",
    webSearchAttempt: "Recherche web pour : '{query}'...",
    webSearchNoResults: "Aucun résultat web trouvé pour '{query}'.",
    webSearchResultsTitle: "Résultats web pour '{query}' :",
    webSearchResultEntry: "{index}. {title}\n   {body}...\n   {href}",
    webSearchError: "Erreur recherche web pour '{query}' : {message}",
    webSearchHttpError: "Erreur HTTP {status} : {statusText}",
    webSearchTimeoutError: "Timeout de la requête web dépassé.",
    listDirectoryAttempt: "Tentative de lister le répertoire : {path}",
    listDirectoryNotDir: "Le chemin spécifié n'est pas un répertoire.",
    listDirectoryEmpty: "(Le répertoire est vide)",
    listDirectorySuccess: "Répertoire listé : {path}",
    listDirectoryError: "Erreur listage répertoire {path} : {message}",
    listDirectoryContentHeader: "Contenu de '{path}' :",
    listDirectoryEntry: "- {name}{isDir}",
    fileWriteConfirmPrompt: "\n--- Confirmation Écriture Fichier ---",
    fileWriteConfirmProposed: "Écriture de fichier proposée : {filepath}",
    fileWriteConfirmContent: "Extrait du contenu :\n{contentSnippet}",
    confirmWrite: "Confirmer l'opération d'écriture ?",
    fileWriteCancelled: "Écriture de fichier annulée.",
    fileWriteAttempt: "Tentative d'écriture du fichier : {filepath}",
    fileWriteSuccess: "Fichier écrit avec succès : {filepath}",
    fileWriteError: "Erreur lors de l'écriture du fichier {filepath} : {message}",

    // Memory Tools
    toolDescriptionGetMemoryKeys: "Liste les clés disponibles sous un chemin spécifique dans la mémoire interne de l'agent. Si aucun chemin n'est fourni, liste les clés à la racine.",
    toolDescriptionGetMemoryValue: "Récupère la valeur stockée à un chemin spécifique dans la mémoire interne de l'agent.",
    toolDescriptionSetMemoryValue: "Définit ou met à jour une valeur à un chemin spécifique dans la mémoire interne de l'agent. Crée les chemins imbriqués s'ils n'existent pas.",
    toolParamMemoryPathOptional: "Le chemin séparé par des points à inspecter (ex: 'system_info.cpu') (optionnel, racine par défaut).",
    toolParamMemoryPathRequired: "Le chemin séparé par des points pour la valeur (ex: 'system_info.cpu_model', 'notes').",
    toolParamMemoryValue: "La valeur à stocker (peut être chaîne, nombre, booléen, objet ou tableau).",
    memoryGettingKeys: "Mémoire : Récupération des clés pour le chemin : {path}",
    errorMemoryNotInitialized: "Erreur : La référence mémoire de l'agent n'est pas initialisée.",
    memoryPathNotFound: "Mémoire : Chemin non trouvé : {path}",
    errorMemoryPathNotObject: "Erreur : Le chemin ne pointe pas vers un objet, impossible de lister les clés : {path}",
    memoryGetKeysSuccess: "Mémoire : Clés récupérées avec succès pour le chemin : {path}",
    memoryGetKeysError: "Mémoire : Erreur lors de la récupération des clés pour {path} : {message}",
    memoryGetKeysErrorFeedback: "Erreur récupération clés mémoire pour {path} : {message}",
    memoryGettingValue: "Mémoire : Récupération de la valeur pour le chemin : {path}",
    errorMemoryPathRequired: "Erreur : Le paramètre de chemin mémoire est requis.",
    memoryGetValueSuccess: "Mémoire : Valeur récupérée avec succès pour le chemin : {path}",
    memoryGetValueError: "Mémoire : Erreur lors de la récupération de la valeur pour {path} : {message}",
    memoryGetValueErrorFeedback: "Erreur récupération valeur mémoire pour {path} : {message}",
    memorySettingValue: "Mémoire : Définition de la valeur pour le chemin : {path}",
    memorySetValueSuccess: "Mémoire : Valeur définie avec succès pour le chemin : {path}",
    memorySetValueSuccessFeedback: "Valeur mémoire définie avec succès pour le chemin : {path}",
    memorySetValueError: "Mémoire : Erreur lors de la définition de la valeur pour {path} : {message}",
    memorySetValueErrorFeedback: "Erreur définition valeur mémoire pour {path} : {message}",

    // utils.js specific
    fileNotFound: "Fichier non trouvé : {filePath}. Utilisation des données par défaut.",
    errorLoadingData: "Erreur chargement données depuis {filePath} :",
    errorSavingData: "Erreur sauvegarde données vers {filePath} :",
    invalidMemoryUpdate: "Objet mémoire invalide passé à updateMemory",

    // New strings for ask_user and auto-continue (French)
    autoContinuePrompt: "Continuer.",
    userRequestedQuit: "L'utilisateur a demandé à quitter via ask_user.",
    errorToolExecutionFailed: "L'exécution de l'outil a échoué : {message}",
    askUserCalledLoopRestart: "ask_user a été appelé, redémarrage de la boucle avec la réponse utilisateur.",
    assistantQuestionPrefix: "Question Assistant :",
    promptUserResponse: "Votre réponse : ",

    // Add missing key (French)
    errorToolArgsParse: "Erreur d'analyse des arguments pour l'outil {functionName}. Args: {args}. Erreur: {message}",

    // Add missing confirmation keys (French)
    commandConfirmYes: "oui",
    commandConfirmNo: "non",
  }
};
